<!DOCTYPE html><html><head>
      <title>MemoryStore</title>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
      
      
      <script src="https://cdn.jsdelivr.net/npm/mermaid@10.9.0/dist/mermaid.min.js"></script>
      
      
      <style>
      code[class*=language-],pre[class*=language-]{color:#333;background:0 0;font-family:Consolas,"Liberation Mono",Menlo,Courier,monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.4;-moz-tab-size:8;-o-tab-size:8;tab-size:8;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none}pre[class*=language-]{padding:.8em;overflow:auto;border-radius:3px;background:#f5f5f5}:not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal;background:#f5f5f5}.token.blockquote,.token.comment{color:#969896}.token.cdata{color:#183691}.token.doctype,.token.macro.property,.token.punctuation,.token.variable{color:#333}.token.builtin,.token.important,.token.keyword,.token.operator,.token.rule{color:#a71d5d}.token.attr-value,.token.regex,.token.string,.token.url{color:#183691}.token.atrule,.token.boolean,.token.code,.token.command,.token.constant,.token.entity,.token.number,.token.property,.token.symbol{color:#0086b3}.token.prolog,.token.selector,.token.tag{color:#63a35c}.token.attr-name,.token.class,.token.class-name,.token.function,.token.id,.token.namespace,.token.pseudo-class,.token.pseudo-element,.token.url-reference .token.variable{color:#795da3}.token.entity{cursor:help}.token.title,.token.title .token.punctuation{font-weight:700;color:#1d3e81}.token.list{color:#ed6a43}.token.inserted{background-color:#eaffea;color:#55a532}.token.deleted{background-color:#ffecec;color:#bd2c00}.token.bold{font-weight:700}.token.italic{font-style:italic}.language-json .token.property{color:#183691}.language-markup .token.tag .token.punctuation{color:#333}.language-css .token.function,code.language-css{color:#0086b3}.language-yaml .token.atrule{color:#63a35c}code.language-yaml{color:#183691}.language-ruby .token.function{color:#333}.language-markdown .token.url{color:#795da3}.language-makefile .token.symbol{color:#795da3}.language-makefile .token.variable{color:#183691}.language-makefile .token.builtin{color:#0086b3}.language-bash .token.keyword{color:#0086b3}pre[data-line]{position:relative;padding:1em 0 1em 3em}pre[data-line] .line-highlight-wrapper{position:absolute;top:0;left:0;background-color:transparent;display:block;width:100%}pre[data-line] .line-highlight{position:absolute;left:0;right:0;padding:inherit 0;margin-top:1em;background:hsla(24,20%,50%,.08);background:linear-gradient(to right,hsla(24,20%,50%,.1) 70%,hsla(24,20%,50%,0));pointer-events:none;line-height:inherit;white-space:pre}pre[data-line] .line-highlight:before,pre[data-line] .line-highlight[data-end]:after{content:attr(data-start);position:absolute;top:.4em;left:.6em;min-width:1em;padding:0 .5em;background-color:hsla(24,20%,50%,.4);color:#f4f1ef;font:bold 65%/1.5 sans-serif;text-align:center;vertical-align:.3em;border-radius:999px;text-shadow:none;box-shadow:0 1px #fff}pre[data-line] .line-highlight[data-end]:after{content:attr(data-end);top:auto;bottom:.4em}html body{font-family:'Helvetica Neue',Helvetica,'Segoe UI',Arial,freesans,sans-serif;font-size:16px;line-height:1.6;color:#333;background-color:#fff;overflow:initial;box-sizing:border-box;word-wrap:break-word}html body>:first-child{margin-top:0}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{line-height:1.2;margin-top:1em;margin-bottom:16px;color:#000}html body h1{font-size:2.25em;font-weight:300;padding-bottom:.3em}html body h2{font-size:1.75em;font-weight:400;padding-bottom:.3em}html body h3{font-size:1.5em;font-weight:500}html body h4{font-size:1.25em;font-weight:600}html body h5{font-size:1.1em;font-weight:600}html body h6{font-size:1em;font-weight:600}html body h1,html body h2,html body h3,html body h4,html body h5{font-weight:600}html body h5{font-size:1em}html body h6{color:#5c5c5c}html body strong{color:#000}html body del{color:#5c5c5c}html body a:not([href]){color:inherit;text-decoration:none}html body a{color:#08c;text-decoration:none}html body a:hover{color:#00a3f5;text-decoration:none}html body img{max-width:100%}html body>p{margin-top:0;margin-bottom:16px;word-wrap:break-word}html body>ol,html body>ul{margin-bottom:16px}html body ol,html body ul{padding-left:2em}html body ol.no-list,html body ul.no-list{padding:0;list-style-type:none}html body ol ol,html body ol ul,html body ul ol,html body ul ul{margin-top:0;margin-bottom:0}html body li{margin-bottom:0}html body li.task-list-item{list-style:none}html body li>p{margin-top:0;margin-bottom:0}html body .task-list-item-checkbox{margin:0 .2em .25em -1.8em;vertical-align:middle}html body .task-list-item-checkbox:hover{cursor:pointer}html body blockquote{margin:16px 0;font-size:inherit;padding:0 15px;color:#5c5c5c;background-color:#f0f0f0;border-left:4px solid #d6d6d6}html body blockquote>:first-child{margin-top:0}html body blockquote>:last-child{margin-bottom:0}html body hr{height:4px;margin:32px 0;background-color:#d6d6d6;border:0 none}html body table{margin:10px 0 15px 0;border-collapse:collapse;border-spacing:0;display:block;width:100%;overflow:auto;word-break:normal;word-break:keep-all}html body table th{font-weight:700;color:#000}html body table td,html body table th{border:1px solid #d6d6d6;padding:6px 13px}html body dl{padding:0}html body dl dt{padding:0;margin-top:16px;font-size:1em;font-style:italic;font-weight:700}html body dl dd{padding:0 16px;margin-bottom:16px}html body code{font-family:Menlo,Monaco,Consolas,'Courier New',monospace;font-size:.85em;color:#000;background-color:#f0f0f0;border-radius:3px;padding:.2em 0}html body code::after,html body code::before{letter-spacing:-.2em;content:'\00a0'}html body pre>code{padding:0;margin:0;word-break:normal;white-space:pre;background:0 0;border:0}html body .highlight{margin-bottom:16px}html body .highlight pre,html body pre{padding:1em;overflow:auto;line-height:1.45;border:#d6d6d6;border-radius:3px}html body .highlight pre{margin-bottom:0;word-break:normal}html body pre code,html body pre tt{display:inline;max-width:initial;padding:0;margin:0;overflow:initial;line-height:inherit;word-wrap:normal;background-color:transparent;border:0}html body pre code:after,html body pre code:before,html body pre tt:after,html body pre tt:before{content:normal}html body blockquote,html body dl,html body ol,html body p,html body pre,html body ul{margin-top:0;margin-bottom:16px}html body kbd{color:#000;border:1px solid #d6d6d6;border-bottom:2px solid #c7c7c7;padding:2px 4px;background-color:#f0f0f0;border-radius:3px}@media print{html body{background-color:#fff}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{color:#000;page-break-after:avoid}html body blockquote{color:#5c5c5c}html body pre{page-break-inside:avoid}html body table{display:table}html body img{display:block;max-width:100%;max-height:100%}html body code,html body pre{word-wrap:break-word;white-space:pre}}.markdown-preview{width:100%;height:100%;box-sizing:border-box}.markdown-preview ul{list-style:disc}.markdown-preview ul ul{list-style:circle}.markdown-preview ul ul ul{list-style:square}.markdown-preview ol{list-style:decimal}.markdown-preview ol ol,.markdown-preview ul ol{list-style-type:lower-roman}.markdown-preview ol ol ol,.markdown-preview ol ul ol,.markdown-preview ul ol ol,.markdown-preview ul ul ol{list-style-type:lower-alpha}.markdown-preview .newpage,.markdown-preview .pagebreak{page-break-before:always}.markdown-preview pre.line-numbers{position:relative;padding-left:3.8em;counter-reset:linenumber}.markdown-preview pre.line-numbers>code{position:relative}.markdown-preview pre.line-numbers .line-numbers-rows{position:absolute;pointer-events:none;top:1em;font-size:100%;left:0;width:3em;letter-spacing:-1px;border-right:1px solid #999;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.markdown-preview pre.line-numbers .line-numbers-rows>span{pointer-events:none;display:block;counter-increment:linenumber}.markdown-preview pre.line-numbers .line-numbers-rows>span:before{content:counter(linenumber);color:#999;display:block;padding-right:.8em;text-align:right}.markdown-preview .mathjax-exps .MathJax_Display{text-align:center!important}.markdown-preview:not([data-for=preview]) .code-chunk .code-chunk-btn-group{display:none}.markdown-preview:not([data-for=preview]) .code-chunk .status{display:none}.markdown-preview:not([data-for=preview]) .code-chunk .output-div{margin-bottom:16px}.markdown-preview .md-toc{padding:0}.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link{display:inline;padding:.25rem 0}.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link div,.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link p{display:inline}.markdown-preview .md-toc .md-toc-link-wrapper.highlighted .md-toc-link{font-weight:800}.scrollbar-style::-webkit-scrollbar{width:8px}.scrollbar-style::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}.scrollbar-style::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,.66);border:4px solid rgba(150,150,150,.66);background-clip:content-box}html body[for=html-export]:not([data-presentation-mode]){position:relative;width:100%;height:100%;top:0;left:0;margin:0;padding:0;overflow:auto}html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{position:relative;top:0;min-height:100vh}@media screen and (min-width:914px){html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{padding:2em calc(50% - 457px + 2em)}}@media screen and (max-width:914px){html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{font-size:14px!important;padding:1em}}@media print{html body[for=html-export]:not([data-presentation-mode]) #sidebar-toc-btn{display:none}}html body[for=html-export]:not([data-presentation-mode]) #sidebar-toc-btn{position:fixed;bottom:8px;left:8px;font-size:28px;cursor:pointer;color:inherit;z-index:99;width:32px;text-align:center;opacity:.4}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] #sidebar-toc-btn{opacity:1}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc{position:fixed;top:0;left:0;width:300px;height:100%;padding:32px 0 48px 0;font-size:14px;box-shadow:0 0 4px rgba(150,150,150,.33);box-sizing:border-box;overflow:auto;background-color:inherit}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar{width:8px}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,.66);border:4px solid rgba(150,150,150,.66);background-clip:content-box}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc a{text-decoration:none}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc{padding:0 16px}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link{display:inline;padding:.25rem 0}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link div,html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link p{display:inline}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper.highlighted .md-toc-link{font-weight:800}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{left:300px;width:calc(100% - 300px);padding:2em calc(50% - 457px - 300px / 2);margin:0;box-sizing:border-box}@media screen and (max-width:1274px){html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{width:100%}}html body[for=html-export]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .markdown-preview{left:50%;transform:translateX(-50%)}html body[for=html-export]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .md-sidebar-toc{display:none}@font-face{font-family:"Material Icons";font-style:normal;font-weight:400;src:local("Material Icons"),local("MaterialIcons-Regular"),url("data:application/x-font-woff;charset=utf-8;base64,d09GRgABAAAAAAfIAAsAAAAADDAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABHU1VCAAABCAAAADMAAABCsP6z7U9TLzIAAAE8AAAARAAAAFZW7kosY21hcAAAAYAAAADTAAACjtP6ytBnbHlmAAACVAAAAxgAAAQ4zRtvlGhlYWQAAAVsAAAALwAAADYRwZsnaGhlYQAABZwAAAAcAAAAJAeKAzxobXR4AAAFuAAAABIAAAA8OGQAAGxvY2EAAAXMAAAAIAAAACAG5AfwbWF4cAAABewAAAAfAAAAIAEfAERuYW1lAAAGDAAAAVcAAAKFkAhoC3Bvc3QAAAdkAAAAYgAAAK2vz7wkeJxjYGRgYOBikGPQYWB0cfMJYeBgYGGAAJAMY05meiJQDMoDyrGAaQ4gZoOIAgCKIwNPAHicY2BkPsQ4gYGVgYOpk+kMAwNDP4RmfM1gxMjBwMDEwMrMgBUEpLmmMDgwVLy4xKzzX4chhrmK4QpQmBEkBwAZygyweJzFkr0NwjAQhZ+TEP6CRUfHBEwRUWaQTICyQbpMwRCskA5RUIONxG0RnnNpKAIV4qzPku/8c353ACYAYrIjCWCuMAh2ptf0/hiL3p/gyPUWa3osqlt0L1zu9r71z8dGrJRykFoauXQd932Lj5vhG+MjxGeYI8MKETObMpslf5EyP8tg+vHun5r539PvlvXzaVhRFVQDTPEWKVQR90KhnnC5Ek67vUKN4VuFasM/ldARj43CCkCsEjpJSoVVgRyU0GVSK6wUpFFCx8lFgX0BiXpRPQB4nE2TTWjcRhTH3xttpDhxN7uxPlp3u/FK7moRPixafRijNosxSw/LUsIwNcaEHPZggo/FmEKMCKWU4kNOOftQSlhE8alnH0Ix9BqWnHooPRrTQ0+mnu2bXTu2pPdGM9LM/6c3fwECTM4gBBMYQNqxzLrZAjqYSlqu2TAHZQA0/DQJH6FtzqGDnvbt4Ggwvzw/nL8EfH8kW0fsuRqhgWXZnY7M1picaUL7Du5BHeDzMIl83dAt016wH1qmvtSMo5R6YRJHTR//FXsff/nj/tc/5K9P5d+nP22+fFK5u7v3K39SW3y+OtDKO3L85vD09PD9z5X17a2N1g4tqk01RlqX7gyoEmnsWQtVr4rtZMmukEaFBZxzefkCn11cyKMLZgshRwgTYNoLNXCBz2ja7HvZG7hDpPSNfoo5vs0knK/9hb+rNpu+8kHPgk/Ao4kK3tWtTpSEtvkA9c+wE6UaUdwieNkaHg55tBEtRiEPw1s0+FtrtTcc9two2lhMknV7PZF/cs6+uUFTmpTGbEx7sQCPSLOttHS3GRltqp7SNzVSKzl6aWnZT/CX5k6/v9N3Hh8fHBwffJVjhrC6OgH5dkIt/tPsq+d/PD5Qz7G7efzq1THFjdZVPe/N6ulQ3JnDWSE5junsFsVIiFwL/htf1S5gJ3BfOcUxfHKLnzqpFpyfZ9cX+/5WB6a+Y0pHpzkNrYNVDwMsikK+y7WuLCRg/oFHkA8VT3rDg5ZnU6ktzzINymV0m74Xd5pfIGXyFeVEQSShkzqG7TBBa2OxVRKitLXv7h3uuftXnXq7lz2tZ/WnWa9dx9dCjDhHzmuVQATlmljr9dZErUydSo2Hbi/b1vXtrOeGCk2/8s3ZlO8+ueJT8BVlw5pGw2oYccdSiHHqx0RlabHqdNR9jAETl6PreJcPBnnfpTLnOQ8C3OV8AmQGzouV1iZdeb5SSIoVc8W8/kcDtksUH5FrU6/aqBqNWcMEzxG4DAQ14qRQhi9mWU0rzepKezbjfgCwQKxVYq5ajRgpRqy45CqwkJydcEkbTkvRz8P5/2ZpDTN4nGNgZGBgAOKb6v+/xvPbfGXgZmEAgeuB2kkI+v8bFgbmKiCXg4EJJAoAPyAKhQB4nGNgZGBg1vmvwxDDwgACQJKRARXwAwAzZQHQeJxjYQCCFAYGFgbSMQAcWACdAAAAAAAAAAwALgBgAIQAmADSAQgBIgE8AVABoAHeAfwCHHicY2BkYGDgZ7BgYGMAASYg5gJCBob/YD4DAA/hAWQAeJxlkbtuwkAURMc88gApQomUJoq0TdIQzEOpUDokKCNR0BuzBiO/tF6QSJcPyHflE9Klyyekz2CuG8cr7547M3d9JQO4xjccnJ57vid2cMHqxDWc40G4Tv1JuEF+Fm6ijRfhM+oz4Ra6eBVu4wZvvMFpXLIa40PYQQefwjVc4Uu4Tv1HuEH+FW7i1mkKn6Hj3Am3sHC6wm08Ou8tpSZGe1av1PKggjSxPd8zJtSGTuinyVGa6/Uu8kxZludCmzxMEzV0B6U004k25W35fj2yNlCBSWM1paujKFWZSbfat+7G2mzc7weiu34aczzFNYGBhgfLfcV6iQP3ACkSaj349AxXSN9IT0j16JepOb01doiKbNWt1ovippz6sVYYwsXgX2rGVFIkq7Pl2PNrI6qW6eOshj0xaSq9mpNEZIWs8LZUfOouNkVXxp/d5woqebeYIf4D2J1ywQB4nG3LOw6AIBAE0B384B+PAkgEa+QwNnYmHt+EpXSal5lkSBBnoP8oCFSo0aCFRIceA0ZMmLFAYSW88rmvtMUjG3RiQ9HvpfusM6zWNmtc5H/iPewha50tOt5PS/QBx2IeSwAA") format("woff")}.admonition{box-shadow:0 2px 2px 0 rgba(0,0,0,.14),0 1px 5px 0 rgba(0,0,0,.12),0 3px 1px -2px rgba(0,0,0,.2);position:relative;margin:1.5625em 0;padding:0 1.2rem;border-left:.4rem solid rgba(68,138,255,.8);border-radius:.2rem;background-color:rgba(255,255,255,.05);overflow:auto}.admonition>p{margin-top:.8rem}.admonition>.admonition-title{margin:0 -1.2rem;padding:.8rem 1.2rem .8rem 3.6rem;border-bottom:1px solid rgba(68,138,255,.2);background-color:rgba(68,138,255,.1);font-weight:700}.admonition>.admonition-title:before{position:absolute;left:1.2rem;font-size:1.5rem;color:rgba(68,138,255,.8);content:"\E3C9"}.admonition>.admonition-title:before{font-family:Material Icons;font-style:normal;font-variant:normal;font-weight:400;line-height:2rem;text-transform:none;white-space:nowrap;speak:none;word-wrap:normal;direction:ltr}.admonition.abstract,.admonition.summary,.admonition.tldr{border-left-color:rgba(0,176,255,.8)}.admonition.abstract>.admonition-title,.admonition.summary>.admonition-title,.admonition.tldr>.admonition-title{background-color:rgba(0,176,255,.1);border-bottom-color:rgba(0,176,255,.2)}.admonition.abstract>.admonition-title:before,.admonition.summary>.admonition-title:before,.admonition.tldr>.admonition-title:before{color:#00b0ff;content:"\E8D2"}.admonition.hint,.admonition.tip{border-left-color:rgba(0,191,165,.8)}.admonition.hint>.admonition-title,.admonition.tip>.admonition-title{background-color:rgba(0,191,165,.1);border-bottom-color:rgba(0,191,165,.2)}.admonition.hint>.admonition-title:before,.admonition.tip>.admonition-title:before{color:#00bfa5;content:"\E80E"}.admonition.info,.admonition.todo{border-left-color:rgba(0,184,212,.8)}.admonition.info>.admonition-title,.admonition.todo>.admonition-title{background-color:rgba(0,184,212,.1);border-bottom-color:rgba(0,184,212,.2)}.admonition.info>.admonition-title:before,.admonition.todo>.admonition-title:before{color:#00b8d4;content:"\E88E"}.admonition.check,.admonition.done,.admonition.success{border-left-color:rgba(0,200,83,.8)}.admonition.check>.admonition-title,.admonition.done>.admonition-title,.admonition.success>.admonition-title{background-color:rgba(0,200,83,.1);border-bottom-color:rgba(0,200,83,.2)}.admonition.check>.admonition-title:before,.admonition.done>.admonition-title:before,.admonition.success>.admonition-title:before{color:#00c853;content:"\E876"}.admonition.faq,.admonition.help,.admonition.question{border-left-color:rgba(100,221,23,.8)}.admonition.faq>.admonition-title,.admonition.help>.admonition-title,.admonition.question>.admonition-title{background-color:rgba(100,221,23,.1);border-bottom-color:rgba(100,221,23,.2)}.admonition.faq>.admonition-title:before,.admonition.help>.admonition-title:before,.admonition.question>.admonition-title:before{color:#64dd17;content:"\E887"}.admonition.attention,.admonition.caution,.admonition.warning{border-left-color:rgba(255,145,0,.8)}.admonition.attention>.admonition-title,.admonition.caution>.admonition-title,.admonition.warning>.admonition-title{background-color:rgba(255,145,0,.1);border-bottom-color:rgba(255,145,0,.2)}.admonition.attention>.admonition-title:before{color:#ff9100;content:"\E417"}.admonition.caution>.admonition-title:before,.admonition.warning>.admonition-title:before{color:#ff9100;content:"\E002"}.admonition.fail,.admonition.failure,.admonition.missing{border-left-color:rgba(255,82,82,.8)}.admonition.fail>.admonition-title,.admonition.failure>.admonition-title,.admonition.missing>.admonition-title{background-color:rgba(255,82,82,.1);border-bottom-color:rgba(255,82,82,.2)}.admonition.fail>.admonition-title:before,.admonition.failure>.admonition-title:before,.admonition.missing>.admonition-title:before{color:#ff5252;content:"\E14C"}.admonition.bug,.admonition.danger,.admonition.error{border-left-color:rgba(255,23,68,.8)}.admonition.bug>.admonition-title,.admonition.danger>.admonition-title,.admonition.error>.admonition-title{background-color:rgba(255,23,68,.1);border-bottom-color:rgba(255,23,68,.2)}.admonition.danger>.admonition-title:before{color:#ff1744;content:"\E3E7"}.admonition.error>.admonition-title:before{color:#ff1744;content:"\E14C"}.admonition.bug>.admonition-title:before{color:#ff1744;content:"\E868"}.admonition.example,.admonition.snippet{border-left-color:rgba(0,184,212,.8)}.admonition.example>.admonition-title,.admonition.snippet>.admonition-title{background-color:rgba(0,184,212,.1);border-bottom-color:rgba(0,184,212,.2)}.admonition.example>.admonition-title:before,.admonition.snippet>.admonition-title:before{color:#00b8d4;content:"\E242"}.admonition.cite,.admonition.quote{border-left-color:rgba(158,158,158,.8)}.admonition.cite>.admonition-title,.admonition.quote>.admonition-title{background-color:rgba(158,158,158,.1);border-bottom-color:rgba(158,158,158,.2)}.admonition.cite>.admonition-title:before,.admonition.quote>.admonition-title:before{color:#9e9e9e;content:"\E244"}
/* Please visit the URL below for more information: */
/*   https://shd101wyy.github.io/markdown-preview-enhanced/#/customize-css */

      </style>
      <!-- The content below will be included at the end of the <head> element. --><script type="text/javascript">
  document.addEventListener("DOMContentLoaded", function () {
    // your code here
  });
</script></head><body for="html-export">
    
    
      <div class="crossnote markdown-preview  ">
      
<h1 id="memorystore">MemoryStore </h1>
<p><code>MemoryStore</code> 类是 Spark 内存存储的一部分，用于在内存中存储块。这些块可以是反序列化的 Java 对象数组或序列化的 ByteBuffer。</p>
<h2 id="类图">类图 </h2>
<p>以下是 <code>MemoryStore</code>以及依赖类的类图和每个成员的注释：</p>
<div class="mermaid">classDiagram
   class MemoryStore {

   -BlockInfoManager blockInfoManager //管理块数据metadata,释放block时加锁操作
   -SerializerManager serializerManager
   -MemoryManager memoryManager //管理内存的分配
   -BlockEvictionHandler blockEvictionHandler//用于内存不足时释放空间（比如到磁盘）
   -LinkedHashMap~BlockId, MemoryEntry~ entries//实际数据的存储

   - putBytes[T](BlockId blockId, Long size, MemoryMode memoryMode, Function0[ChunkedByteBuffer] _bytes)// 将块作为字节存储到内存中。
   - putIterator[T](BlockId blockId, Iterator[T] values, ClassTag[T] classTag, MemoryMode memoryMode, ValuesHolder[T] valuesHolder)// 将块作为值或字节存储到内存中。
   - putIteratorAsValues(BlockId blockId, Iterator[T] values, ClassTag[T] classTag, MemoryMode memoryMode) // 按照value存储，不涉及序列化：DeserializedValuesHolder
   - putIteratorAsBytes(BlockId blockId, Iterator[T] values, ClassTag[T] classTag, MemoryMode memoryMode,) // 按照bytes存储，序列化:SerializedValuesHolder

   }


   class SerializerManager {
      + compressionCodec // 编解码器
      + getSerializer(ct: ClassTag[_], autoPick: Boolean): Serializer
      + shouldCompress(blockId: BlockId): Boolean
      + dataSerializeStream[T: ClassTag](blockId: BlockId,outputStream: OutputStream,values: Iterator[T]) // 对象序列化为流
   }
   SerializerManager --&gt; Serializer : 使用
   class Serializer {
      + newInstance(): SerializerInstance
   }
   Serializer --&gt; SerializerInstance : 使用
   class SerializerInstance {
      + serialize[T: ClassTag](t: T): ByteBuffer // 将对象序列化为buffer
      + deserialize[T: ClassTag](bytes: ByteBuffer): T //将buffer反序列化为对象
      + deserialize[T: ClassTag](bytes: ByteBuffer, loader: ClassLoader): T
      + serializeStream(s: OutputStream): SerializationStream
      + deserializeStream(s: InputStream): DeserializationStream
   }
   SerializerInstance --&gt; SerializationStream :使用
   SerializerInstance --&gt; DeserializationStream :使用
   class SerializationStream {
      + writeObject[T: ClassTag](t: T): SerializationStream; //将对象写入流
      + writeKey[T: ClassTag](key: T): SerializationStream = writeObject(key);
      + writeValue[T: ClassTag](value: T): SerializationStream = writeObject(value);
      + flush(): Unit;
   }
   class DeserializationStream {
      + readObject[T: ClassTag](): T; //读取流为对象
      + readKey[T: ClassTag](): T = readObject[T]();
      + readValue[T: ClassTag](): T = readObject[T]();
   }


   class ValuesHolder {
      + storeValue(value: T)
      + estimatedSize()
      + getBuilder()
   }
   SerializedValuesHolder --&gt; ValuesHolder : 继承
   SerializedValuesHolder --&gt; SerializerManager: 使用
   MemoryStore --&gt; SerializedValuesHolder :使用
   class SerializedValuesHolder {
      + val serializationStream: SerializationStream
      + storeValue(value: T):serializationStream.writeObject(value)(classTag)
   }

   MemoryStore --&gt; DeserializedValuesHolder :使用
   class DeserializedValuesHolder {
      + var vector = new SizeTrackingVector[T]()(classTag)
      + var arrayValues: Array[T] = null
      + storeValue(value: T): Unit//do:vector+=value

   }
   class SizeTrackingVector {
      //可以认为是一个支持append的vector
   }
   DeserializedValuesHolder --&gt;SizeTrackingVector:使用
   DeserializedValuesHolder --&gt; ValuesHolder :继承

   MemoryStore --&gt; blockEvictionHandler : 使用
   class blockEvictionHandler {
      + dropFromMemory(blockId: BlockId,data)
   }
   MemoryStore --&gt; MemoryManager : 使用
   class MemoryManager {
   -onHeapStorageMemoryPool: StorageMemoryPool//堆上存储内存池，仅管理，不是真正的存储
   -offHeapStorageMemoryPool: StorageMemoryPool
   -onHeapExecutionMemoryPool: ExecutionMemoryPool
   -offHeapExecutionMemoryPool: ExecutionMemoryPool
   }

   MemoryManager --&gt; StorageMemoryPool : 使用
   MemoryManager --&gt; ExecutionMemoryPool : 使用

   ExecutionMemoryPool "1" --|&gt; "1" MemoryPool : 继承
   class ExecutionMemoryPool {
      +getMemoryUsageForTask(taskAttemptId: Long)
      +acquireMemory()
      +releaseMemory()
   }

   class StorageMemoryPool {
      +long memoryUsed // 当前使用的内存量
      -Object lock // 用于同步的对象
      -long _memoryUsed // 实际使用的内存量
      -MemoryStore _memoryStore // 内存存储实例,用于驱逐其某些block释放内存
      
      +void setMemoryStore(MemoryStore store) // 设置 MemoryStore 实例
      +boolean acquireMemory(BlockId blockId, long numBytes) // 尝试分配内存
      +boolean acquireMemory(BlockId blockId, long numBytesToAcquire, long numBytesToFree) // 尝试分配内存（重载）
      +void releaseMemory(long size) // 释放指定大小的内存
      +void releaseAllMemory() // 释放所有使用的内存
      +long freeSpaceToShrinkPool(long spaceToFree) // 释放空间以缩小内存池
   }

   class MemoryStore {
      // 这里可以添加 MemoryStore 类的成员和方法
   }

   class BlockId {
      + name: String //unique identifier
      + isRDD // 是否是RDD Block
      + isShuffle 
      + isShuffleChunk
      + isBroadcast
      + override def toString: String = name
   }

   class MemoryMode {
      // 这里可以添加 MemoryMode 类的成员和方法
   }

   StorageMemoryPool "1" -- "1" MemoryStore : 使用
   StorageMemoryPool "1" -- "1" BlockId : 管理
   StorageMemoryPool "1" -- "1" MemoryMode : 类型

   StorageMemoryPool "1" --|&gt; "1" MemoryPool : 继承
   class MemoryPool {
      +long poolSize // 当前池大小
      +long memoryFree // 可用内存量
      +void incrementPoolSize(long delta) // 增加池的大小
      +void decrementPoolSize(long delta) // 减少池的大小
      +long memoryUsed // 已用内存量
      -Object lock // 用于同步的对象
      -long _poolSize // 实际池大小
    }
    MemoryStore --&gt; BlockInfoManager : 使用
    class BlockInfoManager {
      +blockInfoWrappers = new ConcurrentHashMap[BlockId, BlockInfoWrapper]
      +acquireLock(blockId: BlockId,blocking: Boolean)
      +lockForReading(blockId,blocking)
      +lockForWriting(blockId,blocking)
    }
</div><h2 id="blockid">BlockId </h2>
<p>BlockId类用于<strong>标识</strong>不同类型的数据块。在Spark中，数据块是数据的基本单位，数据块的标识对分布式数据处理非常重要。<br>
<code>BlockId</code>是一个抽象类，所有数据块标识类都继承自这个类以下是几种具体的<code>BlockId</code>实现类：</p>
<h3 id="rddblockid"><code>RDDBlockId</code> </h3>
<pre data-role="codeBlock" data-info="scala" class="language-scala scala"><code><span class="token annotation punctuation">@DeveloperApi</span>
<span class="token keyword keyword-case">case</span> <span class="token keyword keyword-class">class</span> RDDBlockId<span class="token punctuation">(</span>rddId<span class="token operator">:</span> <span class="token builtin">Int</span><span class="token punctuation">,</span> splitIndex<span class="token operator">:</span> <span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token keyword keyword-extends">extends</span> BlockId <span class="token punctuation">{</span>
  <span class="token keyword keyword-override">override</span> <span class="token keyword keyword-def">def</span> name<span class="token operator">:</span> <span class="token builtin">String</span> <span class="token operator">=</span> <span class="token string">"rdd_"</span> <span class="token operator">+</span> rddId <span class="token operator">+</span> <span class="token string">"_"</span> <span class="token operator">+</span> splitIndex
<span class="token punctuation">}</span>
</code></pre><p>用于标识RDD数据块，包含RDD ID和分片索引。</p>
<h3 id="shuffleblockid"><code>ShuffleBlockId</code> </h3>
<pre data-role="codeBlock" data-info="scala" class="language-scala scala"><code><span class="token annotation punctuation">@DeveloperApi</span>
<span class="token keyword keyword-case">case</span> <span class="token keyword keyword-class">class</span> ShuffleBlockId<span class="token punctuation">(</span>shuffleId<span class="token operator">:</span> <span class="token builtin">Int</span><span class="token punctuation">,</span> mapId<span class="token operator">:</span> <span class="token builtin">Long</span><span class="token punctuation">,</span> reduceId<span class="token operator">:</span> <span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token keyword keyword-extends">extends</span> BlockId <span class="token punctuation">{</span>
  <span class="token keyword keyword-override">override</span> <span class="token keyword keyword-def">def</span> name<span class="token operator">:</span> <span class="token builtin">String</span> <span class="token operator">=</span> <span class="token string">"shuffle_"</span> <span class="token operator">+</span> shuffleId <span class="token operator">+</span> <span class="token string">"_"</span> <span class="token operator">+</span> mapId <span class="token operator">+</span> <span class="token string">"_"</span> <span class="token operator">+</span> reduceId
<span class="token punctuation">}</span>
</code></pre><p>用于标识Shuffle数据块，包含Shuffle ID、map任务ID和reduce任务ID。</p>
<h2 id="serializermanager">SerializerManager </h2>
<p>SerializerManager 类是 Spark 框架中的一个组件，它负责配置各种 Spark 组件的序列化、压缩和加密。这个类能够自动选择适合的 Serializer 用于 shuffle 操作。</p>
<h3 id="serializermanager的成员和构造方法">SerializerManager的成员和构造方法 </h3>
<pre data-role="codeBlock" data-info="scala" class="language-scala scala"><code><span class="token keyword keyword-private">private</span><span class="token punctuation">[</span>spark<span class="token punctuation">]</span> <span class="token keyword keyword-class">class</span> SerializerManager<span class="token punctuation">(</span>
    defaultSerializer<span class="token operator">:</span> Serializer<span class="token punctuation">,</span>
    conf<span class="token operator">:</span> SparkConf<span class="token punctuation">,</span>
    encryptionKey<span class="token operator">:</span> Option<span class="token punctuation">[</span>Array<span class="token punctuation">[</span><span class="token builtin">Byte</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</code></pre><ul>
<li><code>defaultSerializer</code>: 默认的序列化器。</li>
<li><code>conf</code>: Spark 配置对象。</li>
<li><code>encryptionKey</code>: 可选的加密密钥。</li>
</ul>
<h3 id="配置相关变量">配置相关变量 </h3>
<pre data-role="codeBlock" data-info="scala" class="language-scala scala"><code><span class="token keyword keyword-private">private</span><span class="token punctuation">[</span><span class="token keyword keyword-this">this</span><span class="token punctuation">]</span> <span class="token keyword keyword-val">val</span> compressBroadcast <span class="token operator">=</span> conf<span class="token punctuation">.</span>get<span class="token punctuation">(</span>config<span class="token punctuation">.</span>BROADCAST_COMPRESS<span class="token punctuation">)</span>
<span class="token keyword keyword-private">private</span><span class="token punctuation">[</span><span class="token keyword keyword-this">this</span><span class="token punctuation">]</span> <span class="token keyword keyword-val">val</span> compressShuffle <span class="token operator">=</span> conf<span class="token punctuation">.</span>get<span class="token punctuation">(</span>config<span class="token punctuation">.</span>SHUFFLE_COMPRESS<span class="token punctuation">)</span>
<span class="token keyword keyword-private">private</span><span class="token punctuation">[</span><span class="token keyword keyword-this">this</span><span class="token punctuation">]</span> <span class="token keyword keyword-val">val</span> compressRdds <span class="token operator">=</span> conf<span class="token punctuation">.</span>get<span class="token punctuation">(</span>config<span class="token punctuation">.</span>RDD_COMPRESS<span class="token punctuation">)</span>
<span class="token keyword keyword-private">private</span><span class="token punctuation">[</span><span class="token keyword keyword-this">this</span><span class="token punctuation">]</span> <span class="token keyword keyword-val">val</span> compressShuffleSpill <span class="token operator">=</span> conf<span class="token punctuation">.</span>get<span class="token punctuation">(</span>config<span class="token punctuation">.</span>SHUFFLE_SPILL_COMPRESS<span class="token punctuation">)</span>

<span class="token keyword keyword-private">private</span> <span class="token keyword keyword-lazy">lazy</span> <span class="token keyword keyword-val">val</span> compressionCodec<span class="token operator">:</span> CompressionCodec <span class="token operator">=</span> CompressionCodec<span class="token punctuation">.</span>createCodec<span class="token punctuation">(</span>conf<span class="token punctuation">)</span>
</code></pre><ul>
<li>这些变量是从配置中读取的，决定了是否对广播变量、shuffle 输出、RDD 分区和 shuffle 暂存数据进行压缩。</li>
<li><code>compressionCodec</code> 是用于压缩的编解码器，它是一个懒加载变量，只有在第一次使用时才会初始化。</li>
</ul>
<h3 id="方法">方法 </h3>
<h4 id="获取序列化器">获取序列化器 </h4>
<pre data-role="codeBlock" data-info="scala" class="language-scala scala"><code><span class="token keyword keyword-def">def</span> getSerializer<span class="token punctuation">(</span>ct<span class="token operator">:</span> ClassTag<span class="token punctuation">[</span>_<span class="token punctuation">]</span><span class="token punctuation">,</span> autoPick<span class="token operator">:</span> <span class="token builtin">Boolean</span><span class="token punctuation">)</span><span class="token operator">:</span> Serializer <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>autoPick <span class="token operator">&amp;&amp;</span> canUseKryo<span class="token punctuation">(</span>ct<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    kryoSerializer
  <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token punctuation">{</span>
    defaultSerializer
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-def">def</span> getSerializer<span class="token punctuation">(</span>keyClassTag<span class="token operator">:</span> ClassTag<span class="token punctuation">[</span>_<span class="token punctuation">]</span><span class="token punctuation">,</span> valueClassTag<span class="token operator">:</span> ClassTag<span class="token punctuation">[</span>_<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> Serializer <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>canUseKryo<span class="token punctuation">(</span>keyClassTag<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> canUseKryo<span class="token punctuation">(</span>valueClassTag<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    kryoSerializer
  <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token punctuation">{</span>
    defaultSerializer
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><ul>
<li><code>getSerializer(ct: ClassTag[_], autoPick: Boolean)</code>: 根据类标签和是否自动选择来获取合适的序列化器。</li>
<li><code>getSerializer(keyClassTag: ClassTag[_], valueClassTag: ClassTag[_])</code>: 为键值对 RDD 选择最好的序列化器。</li>
</ul>
<h4 id="是否需要压缩">是否需要压缩 </h4>
<pre data-role="codeBlock" data-info="scala" class="language-scala scala"><code><span class="token keyword keyword-private">private</span> <span class="token keyword keyword-def">def</span> shouldCompress<span class="token punctuation">(</span>blockId<span class="token operator">:</span> BlockId<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Boolean</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  blockId <span class="token keyword keyword-match">match</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-case">case</span> _<span class="token operator">:</span> ShuffleBlockId <span class="token keyword keyword-=>">=&gt;</span> compressShuffle
    <span class="token keyword keyword-case">case</span> _<span class="token operator">:</span> ShuffleBlockChunkId <span class="token keyword keyword-=>">=&gt;</span> compressShuffle
    <span class="token keyword keyword-case">case</span> _<span class="token operator">:</span> BroadcastBlockId <span class="token keyword keyword-=>">=&gt;</span> compressBroadcast
    <span class="token keyword keyword-case">case</span> _<span class="token operator">:</span> RDDBlockId <span class="token keyword keyword-=>">=&gt;</span> compressRdds
    <span class="token keyword keyword-case">case</span> _<span class="token operator">:</span> TempLocalBlockId <span class="token keyword keyword-=>">=&gt;</span> compressShuffleSpill
    <span class="token keyword keyword-case">case</span> _<span class="token operator">:</span> TempShuffleBlockId <span class="token keyword keyword-=>">=&gt;</span> compressShuffle
    <span class="token keyword keyword-case">case</span> _<span class="token operator">:</span> ShuffleBlockBatchId <span class="token keyword keyword-=>">=&gt;</span> compressShuffle
    <span class="token keyword keyword-case">case</span> _ <span class="token keyword keyword-=>">=&gt;</span> <span class="token boolean">false</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><ul>
<li>根据 <code>BlockId</code> 的类型，决定是否需要压缩。</li>
</ul>
<h4 id="包装输入输出流">包装输入/输出流 </h4>
<pre data-role="codeBlock" data-info="scala" class="language-scala scala"><code><span class="token keyword keyword-def">def</span> wrapForCompression<span class="token punctuation">(</span>blockId<span class="token operator">:</span> BlockId<span class="token punctuation">,</span> s<span class="token operator">:</span> OutputStream<span class="token punctuation">)</span><span class="token operator">:</span> OutputStream <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>shouldCompress<span class="token punctuation">(</span>blockId<span class="token punctuation">)</span><span class="token punctuation">)</span> compressionCodec<span class="token punctuation">.</span>compressedOutputStream<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token keyword keyword-else">else</span> s
<span class="token punctuation">}</span>

<span class="token keyword keyword-def">def</span> wrapForCompression<span class="token punctuation">(</span>blockId<span class="token operator">:</span> BlockId<span class="token punctuation">,</span> s<span class="token operator">:</span> InputStream<span class="token punctuation">)</span><span class="token operator">:</span> InputStream <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>shouldCompress<span class="token punctuation">(</span>blockId<span class="token punctuation">)</span><span class="token punctuation">)</span> compressionCodec<span class="token punctuation">.</span>compressedInputStream<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token keyword keyword-else">else</span> s
<span class="token punctuation">}</span>
<span class="token keyword keyword-def">def</span> wrapStream<span class="token punctuation">(</span>blockId<span class="token operator">:</span> BlockId<span class="token punctuation">,</span> s<span class="token operator">:</span> InputStream<span class="token punctuation">)</span><span class="token operator">:</span> InputStream <span class="token operator">=</span> <span class="token punctuation">{</span>
  wrapForCompression<span class="token punctuation">(</span>blockId<span class="token punctuation">,</span> wrapForEncryption<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-def">def</span> wrapStream<span class="token punctuation">(</span>blockId<span class="token operator">:</span> BlockId<span class="token punctuation">,</span> s<span class="token operator">:</span> OutputStream<span class="token punctuation">)</span><span class="token operator">:</span> OutputStream <span class="token operator">=</span> <span class="token punctuation">{</span>
  wrapForCompression<span class="token punctuation">(</span>blockId<span class="token punctuation">,</span> wrapForEncryption<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

</code></pre><ul>
<li>这些方法用于包装输入和输出流，以便添加加密和压缩功能。</li>
</ul>
<h4 id="序列化和反序列化">序列化和反序列化 </h4>
<pre data-role="codeBlock" data-info="scala" class="language-scala scala"><code><span class="token keyword keyword-def">def</span> dataSerializeStream<span class="token punctuation">[</span>T<span class="token operator">:</span> ClassTag<span class="token punctuation">]</span><span class="token punctuation">(</span>
    blockId<span class="token operator">:</span> BlockId<span class="token punctuation">,</span>
    outputStream<span class="token operator">:</span> OutputStream<span class="token punctuation">,</span>
    values<span class="token operator">:</span> Iterator<span class="token punctuation">[</span>T<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Unit</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token keyword keyword-val">val</span> byteStream <span class="token operator">=</span> <span class="token keyword keyword-new">new</span> BufferedOutputStream<span class="token punctuation">(</span>outputStream<span class="token punctuation">)</span>
  <span class="token keyword keyword-val">val</span> autoPick <span class="token operator">=</span> <span class="token operator">!</span>blockId<span class="token punctuation">.</span>isInstanceOf<span class="token punctuation">[</span>StreamBlockId<span class="token punctuation">]</span>
  <span class="token keyword keyword-val">val</span> ser <span class="token operator">=</span> getSerializer<span class="token punctuation">(</span>implicitly<span class="token punctuation">[</span>ClassTag<span class="token punctuation">[</span>T<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> autoPick<span class="token punctuation">)</span><span class="token punctuation">.</span>newInstance<span class="token punctuation">(</span><span class="token punctuation">)</span>
  ser<span class="token punctuation">.</span>serializeStream<span class="token punctuation">(</span>wrapForCompression<span class="token punctuation">(</span>blockId<span class="token punctuation">,</span> byteStream<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>writeAll<span class="token punctuation">(</span>values<span class="token punctuation">)</span><span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-def">def</span> dataSerialize<span class="token punctuation">[</span>T<span class="token operator">:</span> ClassTag<span class="token punctuation">]</span><span class="token punctuation">(</span>
    blockId<span class="token operator">:</span> BlockId<span class="token punctuation">,</span>
    values<span class="token operator">:</span> Iterator<span class="token punctuation">[</span>T<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> ChunkedByteBuffer <span class="token operator">=</span> <span class="token punctuation">{</span>
  dataSerializeWithExplicitClassTag<span class="token punctuation">(</span>blockId<span class="token punctuation">,</span> values<span class="token punctuation">,</span> implicitly<span class="token punctuation">[</span>ClassTag<span class="token punctuation">[</span>T<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-def">def</span> dataSerializeWithExplicitClassTag<span class="token punctuation">(</span>
    blockId<span class="token operator">:</span> BlockId<span class="token punctuation">,</span>
    values<span class="token operator">:</span> Iterator<span class="token punctuation">[</span>_<span class="token punctuation">]</span><span class="token punctuation">,</span>
    classTag<span class="token operator">:</span> ClassTag<span class="token punctuation">[</span>_<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> ChunkedByteBuffer <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token keyword keyword-val">val</span> bbos <span class="token operator">=</span> <span class="token keyword keyword-new">new</span> ChunkedByteBufferOutputStream<span class="token punctuation">(</span><span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">4</span><span class="token punctuation">,</span> ByteBuffer<span class="token punctuation">.</span>allocate<span class="token punctuation">)</span>
  <span class="token keyword keyword-val">val</span> byteStream <span class="token operator">=</span> <span class="token keyword keyword-new">new</span> BufferedOutputStream<span class="token punctuation">(</span>bbos<span class="token punctuation">)</span>
  <span class="token keyword keyword-val">val</span> autoPick <span class="token operator">=</span> <span class="token operator">!</span>blockId<span class="token punctuation">.</span>isInstanceOf<span class="token punctuation">[</span>StreamBlockId<span class="token punctuation">]</span>
  <span class="token keyword keyword-val">val</span> ser <span class="token operator">=</span> getSerializer<span class="token punctuation">(</span>classTag<span class="token punctuation">,</span> autoPick<span class="token punctuation">)</span><span class="token punctuation">.</span>newInstance<span class="token punctuation">(</span><span class="token punctuation">)</span>
  ser<span class="token punctuation">.</span>serializeStream<span class="token punctuation">(</span>wrapForCompression<span class="token punctuation">(</span>blockId<span class="token punctuation">,</span> byteStream<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>writeAll<span class="token punctuation">(</span>values<span class="token punctuation">)</span><span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>
  bbos<span class="token punctuation">.</span>toChunkedByteBuffer
<span class="token punctuation">}</span>

<span class="token keyword keyword-def">def</span> dataDeserializeStream<span class="token punctuation">[</span>T<span class="token punctuation">]</span><span class="token punctuation">(</span>
    blockId<span class="token operator">:</span> BlockId<span class="token punctuation">,</span>
    inputStream<span class="token operator">:</span> InputStream<span class="token punctuation">)</span>
    <span class="token punctuation">(</span>classTag<span class="token operator">:</span> ClassTag<span class="token punctuation">[</span>T<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> Iterator<span class="token punctuation">[</span>T<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token keyword keyword-val">val</span> stream <span class="token operator">=</span> <span class="token keyword keyword-new">new</span> BufferedInputStream<span class="token punctuation">(</span>inputStream<span class="token punctuation">)</span>
  <span class="token keyword keyword-val">val</span> autoPick <span class="token operator">=</span> <span class="token operator">!</span>blockId<span class="token punctuation">.</span>isInstanceOf<span class="token punctuation">[</span>StreamBlockId<span class="token punctuation">]</span>
  getSerializer<span class="token punctuation">(</span>classTag<span class="token punctuation">,</span> autoPick<span class="token punctuation">)</span>
    <span class="token punctuation">.</span>newInstance<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span>deserializeStream<span class="token punctuation">(</span>wrapForCompression<span class="token punctuation">(</span>blockId<span class="token punctuation">,</span> stream<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span>asIterator<span class="token punctuation">.</span>asInstanceOf<span class="token punctuation">[</span>Iterator<span class="token punctuation">[</span>T<span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre><ul>
<li><code>dataSerializeStream</code> 和 <code>dataSerialize</code> 用于将数据序列化到流或 <code>ChunkedByteBuffer</code> 中。</li>
<li><code>dataDeserializeStream</code> 用于从输入流中反序列化数据。</li>
</ul>
<h2 id="serializedvaluesholder">SerializedValuesHolder </h2>
<p>SerializedValuesHolder是用于存储序列化值的持有者类。该类封装了序列化值的存储和管理逻辑，主要用于 Spark 的存储模块</p>
<pre data-role="codeBlock" data-info="scala" class="language-scala scala"><code><span class="token keyword keyword-class">class</span> SerializedValuesHolder<span class="token punctuation">[</span>T<span class="token punctuation">]</span><span class="token punctuation">(</span>
    blockId<span class="token operator">:</span> BlockId<span class="token punctuation">,</span>
    chunkSize<span class="token operator">:</span> <span class="token builtin">Int</span><span class="token punctuation">,</span>
    classTag<span class="token operator">:</span> ClassTag<span class="token punctuation">[</span>T<span class="token punctuation">]</span><span class="token punctuation">,</span>
    memoryMode<span class="token operator">:</span> MemoryMode<span class="token punctuation">,</span>
    serializerManager<span class="token operator">:</span> SerializerManager<span class="token punctuation">)</span> <span class="token keyword keyword-extends">extends</span> ValuesHolder<span class="token punctuation">[</span>T<span class="token punctuation">]</span> <span class="token punctuation">{</span>
</code></pre><p>SerializedValuesHolder存储对象时，调用<code>storeValue(value: T)</code>,将对象写入<code>serializationStream</code>,最后在unroll结束后调用getBuilder()关闭流，将流转为buffer。</p>
<pre data-role="codeBlock" data-info="scala" class="language-scala scala"><code><span class="token keyword keyword-val">val</span> serializationStream<span class="token operator">:</span> SerializationStream <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token keyword keyword-val">val</span> autoPick <span class="token operator">=</span> <span class="token operator">!</span>blockId<span class="token punctuation">.</span>isInstanceOf<span class="token punctuation">[</span>StreamBlockId<span class="token punctuation">]</span>
  <span class="token keyword keyword-val">val</span> ser <span class="token operator">=</span> serializerManager<span class="token punctuation">.</span>getSerializer<span class="token punctuation">(</span>classTag<span class="token punctuation">,</span> autoPick<span class="token punctuation">)</span><span class="token punctuation">.</span>newInstance<span class="token punctuation">(</span><span class="token punctuation">)</span>
  ser<span class="token punctuation">.</span>serializeStream<span class="token punctuation">(</span>serializerManager<span class="token punctuation">.</span>wrapForCompression<span class="token punctuation">(</span>blockId<span class="token punctuation">,</span> redirectableStream<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword keyword-override">override</span> <span class="token keyword keyword-def">def</span> storeValue<span class="token punctuation">(</span>value<span class="token operator">:</span> T<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Unit</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  serializationStream<span class="token punctuation">.</span>writeObject<span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">(</span>classTag<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword keyword-override">override</span> <span class="token keyword keyword-def">def</span> getBuilder<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> MemoryEntryBuilder<span class="token punctuation">[</span>T<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword keyword-new">new</span> MemoryEntryBuilder<span class="token punctuation">[</span>T<span class="token punctuation">]</span> <span class="token punctuation">{</span>
   <span class="token comment">// We successfully unrolled the entirety of this block</span>
   serializationStream<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>

   <span class="token keyword keyword-override">override</span> <span class="token keyword keyword-def">def</span> preciseSize<span class="token operator">:</span> <span class="token builtin">Long</span> <span class="token operator">=</span> bbos<span class="token punctuation">.</span>size

   <span class="token keyword keyword-override">override</span> <span class="token keyword keyword-def">def</span> build<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> MemoryEntry<span class="token punctuation">[</span>T<span class="token punctuation">]</span> <span class="token operator">=</span>
   SerializedMemoryEntry<span class="token punctuation">[</span>T<span class="token punctuation">]</span><span class="token punctuation">(</span>bbos<span class="token punctuation">.</span>toChunkedByteBuffer<span class="token punctuation">,</span> memoryMode<span class="token punctuation">,</span> classTag<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><h3 id="serializermanager-总结">SerializerManager 总结 </h3>
<p><code>SerializerManager</code> 类提供了对序列化、压缩和加密的全面管理。通过配置和上下文自动选择合适的序列化器，并通过包装输入输出流实现对数据的压缩和加密。这样设计的目的在于提高 Spark 处理数据的灵活性和安全性。</p>
<h2 id="memorymanager">MemoryManager </h2>
<p><code>MemoryManager</code> 类是 Spark 内存管理的抽象基类，负责在执行内存和存储内存之间分配和管理内存。它使用 <code>StorageMemoryPool</code> 和 <code>ExecutionMemoryPool</code> 来管理不同类型的内存池，并根据配置来处理堆内存和非堆内存的使用。</p>
<h3 id="mermaid-图表"><code>Mermaid</code> 图表 </h3>
<p>以下是 <code>MemoryManager</code> 类的 <code>Mermaid</code> 图表，展示了主要字段和方法的关系及其注释。</p>
<div class="mermaid">classDiagram
    class MemoryManager {
        +conf: SparkConf
        +numCores: Int
        +onHeapStorageMemory: Long
        +onHeapExecutionMemory: Long
        +onHeapStorageMemoryPool: StorageMemoryPool
        +offHeapStorageMemoryPool: StorageMemoryPool
        +onHeapExecutionMemoryPool: ExecutionMemoryPool
        +offHeapExecutionMemoryPool: ExecutionMemoryPool
        +maxOffHeapMemory: Long
        +offHeapStorageMemory: Long
        +tungstenMemoryMode: MemoryMode
        +defaultPageSizeBytes: Long
        +pageSizeBytes: Long
        +tungstenMemoryAllocator: MemoryAllocator

        +acquireStorageMemory(blockId: BlockId, numBytes: Long, memoryMode: MemoryMode): Boolean
        +acquireUnrollMemory(blockId: BlockId, numBytes: Long, memoryMode: MemoryMode): Boolean
        +acquireExecutionMemory(numBytes: Long, taskAttemptId: Long, memoryMode: MemoryMode): Long
        +releaseExecutionMemory(numBytes: Long, taskAttemptId: Long, memoryMode: MemoryMode): Unit
        +releaseAllExecutionMemoryForTask(taskAttemptId: Long): Long
        +releaseStorageMemory(numBytes: Long, memoryMode: MemoryMode): Unit
        +releaseAllStorageMemory(): Unit
        +releaseUnrollMemory(numBytes: Long, memoryMode: MemoryMode): Unit
        +executionMemoryUsed: Long
        +storageMemoryUsed: Long
        +onHeapExecutionMemoryUsed: Long
        +offHeapExecutionMemoryUsed: Long
        +onHeapStorageMemoryUsed: Long
        +offHeapStorageMemoryUsed: Long
        +getExecutionMemoryUsageForTask(taskAttemptId: Long): Long
        +tungstenMemoryAllocator: MemoryAllocator
    }

    class StorageMemoryPool {
        &lt;&lt;interface&gt;&gt;
    }

    class ExecutionMemoryPool {
        &lt;&lt;interface&gt;&gt;
    }

    class SparkConf {
        &lt;&lt;interface&gt;&gt;
    }

    class BlockId {
        &lt;&lt;interface&gt;&gt;
    }

    class MemoryMode {
        &lt;&lt;interface&gt;&gt;
    }

    class MemoryAllocator {
        &lt;&lt;interface&gt;&gt;
    }

    MemoryManager --&gt; StorageMemoryPool : uses
    MemoryManager --&gt; ExecutionMemoryPool : uses
    MemoryManager --&gt; SparkConf : uses
    MemoryManager --&gt; BlockId : uses
    MemoryManager --&gt; MemoryMode : uses
    MemoryManager --&gt; MemoryAllocator : uses
</div><h3 id="注释说明">注释说明 </h3>
<ul>
<li>
<p><strong>字段</strong></p>
<ul>
<li><code>onHeapStorageMemoryPool</code> 和 <code>offHeapStorageMemoryPool</code> 负责管理存储内存的堆和非堆内存。</li>
<li><code>onHeapExecutionMemoryPool</code> 和 <code>offHeapExecutionMemoryPool</code> 负责管理执行内存的堆和非堆内存。</li>
<li><code>maxOffHeapMemory</code> 和 <code>offHeapStorageMemory</code> 用于配置和管理非堆内存的使用。</li>
<li><code>tungstenMemoryMode</code> 决定了内存是使用堆内存还是非堆内存。</li>
<li><code>defaultPageSizeBytes</code> 和 <code>pageSizeBytes</code> 确定页面的默认大小。</li>
</ul>
</li>
<li>
<p><strong>方法</strong></p>
<ul>
<li><code>acquireStorageMemory</code> 和 <code>acquireUnrollMemory</code> 用于请求存储和解压内存。</li>
<li><code>acquireExecutionMemory</code> 用于请求执行内存。</li>
<li><code>releaseExecutionMemory</code> 和 <code>releaseStorageMemory</code> 用于释放内存。</li>
<li><code>executionMemoryUsed</code> 和 <code>storageMemoryUsed</code> 提供当前使用的内存量。</li>
</ul>
</li>
</ul>
<h3 id="主要字段和方法">主要字段和方法 </h3>
<ol>
<li>
<p><strong>字段</strong></p>
<ul>
<li>
<p><code>onHeapStorageMemoryPool</code> 和 <code>offHeapStorageMemoryPool</code></p>
<ul>
<li><code>StorageMemoryPool</code> 的实例，用于管理堆内存和非堆内存中的存储内存。</li>
</ul>
</li>
<li>
<p><code>onHeapExecutionMemoryPool</code> 和 <code>offHeapExecutionMemoryPool</code></p>
<ul>
<li><code>ExecutionMemoryPool</code> 的实例，用于管理堆内存和非堆内存中的执行内存。</li>
</ul>
</li>
<li>
<p><code>maxOffHeapMemory</code></p>
<ul>
<li>最大的非堆内存大小。</li>
</ul>
</li>
<li>
<p><code>offHeapStorageMemory</code></p>
<ul>
<li>分配给存储的非堆内存大小。</li>
</ul>
</li>
<li>
<p><code>tungstenMemoryMode</code></p>
<ul>
<li>指示 Tungsten 内存分配是使用堆内存还是非堆内存。</li>
</ul>
</li>
<li>
<p><code>defaultPageSizeBytes</code></p>
<ul>
<li>默认的页面大小。</li>
</ul>
</li>
<li>
<p><code>pageSizeBytes</code></p>
<ul>
<li>配置的页面大小。</li>
</ul>
</li>
<li>
<p><code>tungstenMemoryAllocator</code></p>
<ul>
<li>用于 Tungsten 内存的分配器。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>方法</strong></p>
<ul>
<li>
<p><code>acquireStorageMemory</code></p>
<ul>
<li>请求存储内存，必要时会回收已有内存。</li>
</ul>
</li>
<li>
<p><code>acquireUnrollMemory</code></p>
<ul>
<li>请求解压内存，允许子类区分存储内存和解压内存的行为。</li>
</ul>
</li>
<li>
<p><code>acquireExecutionMemory</code></p>
<ul>
<li>请求执行内存，用于当前任务。</li>
</ul>
</li>
<li>
<p><code>releaseExecutionMemory</code></p>
<ul>
<li>释放执行内存。</li>
</ul>
</li>
<li>
<p><code>releaseAllExecutionMemoryForTask</code></p>
<ul>
<li>释放所有执行内存。</li>
</ul>
</li>
<li>
<p><code>releaseStorageMemory</code></p>
<ul>
<li>释放存储内存。</li>
</ul>
</li>
<li>
<p><code>releaseAllStorageMemory</code></p>
<ul>
<li>释放所有存储内存。</li>
</ul>
</li>
<li>
<p><code>releaseUnrollMemory</code></p>
<ul>
<li>释放解压内存。</li>
</ul>
</li>
<li>
<p><code>executionMemoryUsed</code> 和 <code>storageMemoryUsed</code></p>
<ul>
<li>获取当前使用的执行内存和存储内存。</li>
</ul>
</li>
<li>
<p><code>getExecutionMemoryUsageForTask</code></p>
<ul>
<li>获取给定任务的执行内存使用情况。</li>
</ul>
</li>
<li>
<p><code>tungstenMemoryAllocator</code></p>
<ul>
<li>根据内存模式选择合适的内存分配器。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>在 <code>MemoryManager</code> 类中，各内存池的大小确定过程如下：</p>
<h3 id="内存池大小的确定">内存池大小的确定 </h3>
<ol>
<li>
<p><strong>堆内存池（On-Heap Memory Pools）</strong></p>
<ul>
<li>
<p><code>onHeapStorageMemoryPool</code></p>
<ul>
<li><strong>大小确定</strong>: <code>onHeapStorageMemory</code>。</li>
<li><strong>说明</strong>: 在构造函数中，<code>onHeapStorageMemoryPool</code> 的大小由 <code>onHeapStorageMemory</code> 确定。<code>onHeapStorageMemory</code> 是通过配置文件（<code>SparkConf</code>）中指定的配置项来确定的，例如 <code>spark.memory.storageFraction</code>，它决定了堆内存中分配给存储的比例。</li>
</ul>
</li>
<li>
<p><code>onHeapExecutionMemoryPool</code></p>
<ul>
<li><strong>大小确定</strong>: <code>onHeapExecutionMemory</code>。</li>
<li><strong>说明</strong>: <code>onHeapExecutionMemoryPool</code> 的大小由 <code>onHeapExecutionMemory</code> 确定。<code>onHeapExecutionMemory</code> 是通过配置文件（<code>SparkConf</code>）中的配置项 <code>spark.memory.fraction</code> 来决定的，这个配置项定义了总堆内存中分配给执行内存的比例。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>非堆内存池（Off-Heap Memory Pools）</strong></p>
<ul>
<li>
<p><code>offHeapStorageMemoryPool</code></p>
<ul>
<li><strong>大小确定</strong>: <code>offHeapStorageMemory</code>。</li>
<li><strong>说明</strong>: 在构造函数中，<code>offHeapStorageMemoryPool</code> 的大小由 <code>offHeapStorageMemory</code> 确定。<code>offHeapStorageMemory</code> 是通过配置项 <code>spark.memory.offHeap.size</code> 和 <code>spark.memory.storageFraction</code> 计算得出的。具体来说，<code>offHeapStorageMemory</code> 是从 <code>maxOffHeapMemory</code> 中按照 <code>spark.memory.storageFraction</code> 配置项计算出来的。这个值决定了非堆内存中用于存储的内存量。</li>
</ul>
</li>
<li>
<p><code>offHeapExecutionMemoryPool</code></p>
<ul>
<li><strong>大小确定</strong>: <code>maxOffHeapMemory - offHeapStorageMemory</code>。</li>
<li><strong>说明</strong>: <code>offHeapExecutionMemoryPool</code> 的大小是剩余的非堆内存量，即 <code>maxOffHeapMemory</code> 减去 <code>offHeapStorageMemory</code>。这个值决定了非堆内存中用于执行的内存量。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="计算过程">计算过程 </h3>
<ol>
<li>
<p><strong>堆内存池的大小计算</strong></p>
<ul>
<li><code>onHeapStorageMemory</code> 和 <code>onHeapExecutionMemory</code> 分别由 <code>spark.memory.storageFraction</code> 和 <code>spark.memory.fraction</code> 配置项来确定。这两个值是对堆内存进行分配时的依据。</li>
</ul>
</li>
<li>
<p><strong>非堆内存池的大小计算</strong></p>
<ul>
<li><code>maxOffHeapMemory</code> 由 <code>spark.memory.offHeap.size</code> 配置项确定，表示总的非堆内存大小。</li>
<li><code>offHeapStorageMemory</code> 是从 <code>maxOffHeapMemory</code> 中分配给存储的内存，计算公式为 <code>maxOffHeapMemory * spark.memory.storageFraction</code>。</li>
<li><code>offHeapExecutionMemory</code> 是非堆内存中剩余的部分，即 <code>maxOffHeapMemory - offHeapStorageMemory</code>。</li>
</ul>
</li>
</ol>
<h3 id="示例">示例 </h3>
<p>假设有如下配置：</p>
<ul>
<li><code>spark.memory.storageFraction = 0.5</code></li>
<li><code>spark.memory.fraction = 0.6</code></li>
<li><code>spark.memory.offHeap.size = 2GB</code> (即 2 <em>1024</em> 1024 * 1024 字节)</li>
</ul>
<p>那么计算结果如下：</p>
<ul>
<li>
<p><strong>堆内存</strong>: 假设堆内存总量为 4GB (即 4 <em>1024</em> 1024 * 1024 字节)</p>
<ul>
<li><code>onHeapStorageMemory = 0.5 * 4GB = 2GB</code></li>
<li><code>onHeapExecutionMemory = 0.6 * 4GB - onHeapStorageMemory = 2.4GB - 2GB = 0.4GB</code></li>
</ul>
</li>
<li>
<p><strong>非堆内存</strong>:</p>
<ul>
<li><code>offHeapStorageMemory = 2GB * 0.5 = 1GB</code></li>
<li><code>offHeapExecutionMemory = 2GB - 1GB = 1GB</code></li>
</ul>
</li>
</ul>
<p>这些计算确保了 Spark 可以根据配置和实际内存资源进行适当的内存分配和管理。</p>
<h2 id="blockinfomanager">BlockInfoManager </h2>
<p><code>BlockInfoManager</code> 是 Spark 的一个重要组件，负责跟踪和管理 Spark 存储系统中块的<strong>元数据</strong>，并处理<strong>块的锁定机制</strong>。它使用读写锁来确保对块的并发访问不会导致竞争条件。</p>
<h3 id="主要功能">主要功能 </h3>
<ol>
<li>
<p><strong>块信息存储</strong></p>
<ul>
<li><code>blockInfoWrappers</code>: 存储每个块的元数据，使用 <code>ConcurrentHashMap</code> 进行并发安全操作。每个块的元数据由 <code>BlockInfoWrapper</code> 封装，该封装包括 <code>BlockInfo</code> 对象和一个锁 (<code>Lock</code>)。</li>
</ul>
</li>
<li>
<p><strong>块可见性跟踪</strong></p>
<ul>
<li><code>invisibleRDDBlocks</code>: 记录不可见的 RDD 块。此集合用于管理块在缓存中的可见性，只有在 <code>trackingCacheVisibility</code> 启用时才会使用。</li>
</ul>
</li>
<li>
<p><strong>锁管理</strong></p>
<ul>
<li><code>locks</code>: 使用 <code>Striped.lock</code> 来控制对块信息的多线程访问。每个块有一个独特的锁，这样可以避免在 <code>lockNewBlockForWriting</code> 方法中的竞争条件。</li>
<li><code>writeLocksByTask</code>: 跟踪每个任务锁定的块的集合。</li>
<li><code>readLocksByTask</code>: 跟踪每个任务锁定的块的集合以及锁定次数。</li>
</ul>
</li>
</ol>
<h3 id="核心方法">核心方法 </h3>
<ol>
<li>
<p><strong><code>lockForReading</code></strong></p>
<ul>
<li>锁定一个块用于读取。如果块已经被其他任务锁定为写入，则会根据 <code>blocking</code> 参数决定是否阻塞。</li>
</ul>
</li>
<li>
<p><strong><code>lockForWriting</code></strong></p>
<ul>
<li>锁定一个块用于写入。如果块已经被锁定为读取或写入，则会根据 <code>blocking</code> 参数决定是否阻塞。</li>
</ul>
</li>
<li>
<p><strong><code>assertBlockIsLockedForWriting</code></strong></p>
<ul>
<li>检查当前任务是否持有写锁。如果不是，则抛出异常。</li>
</ul>
</li>
<li>
<p><strong><code>unlock</code></strong></p>
<ul>
<li>释放块的锁。根据传入的任务尝试 ID，释放相应的读锁或写锁。</li>
</ul>
</li>
<li>
<p><strong><code>lockNewBlockForWriting</code></strong></p>
<ul>
<li>尝试为新块获取写锁。该方法会确保第一个写入操作获得锁，而其他线程则等待或者获取读取锁。</li>
</ul>
</li>
<li>
<p><strong><code>releaseAllLocksForTask</code></strong></p>
<ul>
<li>释放给定任务持有的所有锁，并更新全局锁计数。</li>
</ul>
</li>
<li>
<p><strong><code>removeBlock</code></strong></p>
<ul>
<li>移除块并释放写锁。这要求在调用时必须持有写锁。</li>
</ul>
</li>
<li>
<p><strong><code>clear</code></strong></p>
<ul>
<li>清除所有状态，通常在系统关闭时调用。</li>
</ul>
</li>
</ol>
<h3 id="重要的数据结构">重要的数据结构 </h3>
<ul>
<li>
<p><strong><code>BlockInfo</code></strong></p>
<ul>
<li>存储每个块的基本信息，如块大小、读锁计数、写锁任务 ID 等。</li>
</ul>
</li>
<li>
<p><strong><code>BlockInfoWrapper</code></strong></p>
<ul>
<li>封装 <code>BlockInfo</code> 对象和一个锁 (<code>Lock</code>)，用于确保对块信息的线程安全操作。</li>
</ul>
</li>
<li>
<p><strong><code>Striped.lock</code></strong></p>
<ul>
<li>用于控制多线程对块信息的访问，通过为每个块分配独特的锁来减少锁竞争。</li>
</ul>
</li>
</ul>
<h3 id="使用场景">使用场景 </h3>
<ul>
<li>
<p><strong>读写操作</strong></p>
<ul>
<li><code>BlockInfoManager</code> 确保在读取或写入块时不会发生数据竞争。例如，多个任务可以同时读取一个块，但只有一个任务可以写入一个块。</li>
</ul>
</li>
<li>
<p><strong>任务管理</strong></p>
<ul>
<li>通过 <code>writeLocksByTask</code> 和 <code>readLocksByTask</code>，<code>BlockInfoManager</code> 追踪每个任务对块的操作，确保任务完成后能正确释放锁。</li>
</ul>
</li>
</ul>
<p>整体来看，<code>BlockInfoManager</code> 通过锁机制和数据结构来管理和保护块的元数据，确保 Spark 存储系统的并发安全性和有效性。</p>
<h2 id="memorystore-源码分析">MemoryStore 源码分析 </h2>
<h3 id="类定义和构造函数">类定义和构造函数 </h3>
<pre data-role="codeBlock" data-info="scala" class="language-scala scala"><code><span class="token keyword keyword-private">private</span><span class="token punctuation">[</span>spark<span class="token punctuation">]</span> <span class="token keyword keyword-class">class</span> MemoryStore<span class="token punctuation">(</span>
    conf<span class="token operator">:</span> SparkConf<span class="token punctuation">,</span>
    blockInfoManager<span class="token operator">:</span> BlockInfoManager<span class="token punctuation">,</span>
    serializerManager<span class="token operator">:</span> SerializerManager<span class="token punctuation">,</span>
    memoryManager<span class="token operator">:</span> MemoryManager<span class="token punctuation">,</span>
    blockEvictionHandler<span class="token operator">:</span> BlockEvictionHandler<span class="token punctuation">)</span>
  <span class="token keyword keyword-extends">extends</span> Logging <span class="token punctuation">{</span>
</code></pre><ul>
<li><code>MemoryStore</code> 是一个私有类，扩展了 <code>Logging</code>，允许记录日志。</li>
<li>它依赖于 <code>SparkConf</code>、<code>BlockInfoManager</code>、<code>SerializerManager</code>、<code>MemoryManager</code> 和 <code>BlockEvictionHandler</code> 作为构造函数参数。</li>
</ul>
<h3 id="成员变量">成员变量 </h3>
<pre data-role="codeBlock" data-info="scala" class="language-scala scala"><code><span class="token keyword keyword-private">private</span> <span class="token keyword keyword-val">val</span> entries <span class="token operator">=</span> <span class="token keyword keyword-new">new</span> LinkedHashMap<span class="token punctuation">[</span>BlockId<span class="token punctuation">,</span> MemoryEntry<span class="token punctuation">[</span>_<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">,</span> <span class="token number">0.75f</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
<span class="token keyword keyword-private">private</span> <span class="token keyword keyword-val">val</span> onHeapUnrollMemoryMap <span class="token operator">=</span> mutable<span class="token punctuation">.</span>HashMap<span class="token punctuation">[</span><span class="token builtin">Long</span><span class="token punctuation">,</span> <span class="token builtin">Long</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword keyword-private">private</span> <span class="token keyword keyword-val">val</span> offHeapUnrollMemoryMap <span class="token operator">=</span> mutable<span class="token punctuation">.</span>HashMap<span class="token punctuation">[</span><span class="token builtin">Long</span><span class="token punctuation">,</span> <span class="token builtin">Long</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword keyword-private">private</span> <span class="token keyword keyword-val">val</span> unrollMemoryThreshold<span class="token operator">:</span> <span class="token builtin">Long</span> <span class="token operator">=</span> conf<span class="token punctuation">.</span>get<span class="token punctuation">(</span>STORAGE_UNROLL_MEMORY_THRESHOLD<span class="token punctuation">)</span>
</code></pre><ul>
<li><code>entries</code>: 用于存储块的 LinkedHashMap，允许按照最近最少使用 (LRU) 的顺序进行迭代。</li>
<li><code>onHeapUnrollMemoryMap</code> 和 <code>offHeapUnrollMemoryMap</code>: 记录每个任务尝试展开块时所用的堆内和堆外内存。</li>
<li><code>unrollMemoryThreshold</code>: 在展开任何块之前请求的初始内存量。</li>
</ul>
<h3 id="内存管理">内存管理 </h3>
<pre data-role="codeBlock" data-info="scala" class="language-scala scala"><code><span class="token keyword keyword-private">private</span> <span class="token keyword keyword-def">def</span> maxMemory<span class="token operator">:</span> <span class="token builtin">Long</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    memoryManager<span class="token punctuation">.</span>maxOnHeapStorageMemory <span class="token operator">+</span> memoryManager<span class="token punctuation">.</span>maxOffHeapStorageMemory
<span class="token punctuation">}</span>

<span class="token keyword keyword-private">private</span> <span class="token keyword keyword-def">def</span> memoryUsed<span class="token operator">:</span> <span class="token builtin">Long</span> <span class="token operator">=</span> memoryManager<span class="token punctuation">.</span>storageMemoryUsed

<span class="token keyword keyword-private">private</span> <span class="token keyword keyword-def">def</span> blocksMemoryUsed<span class="token operator">:</span> <span class="token builtin">Long</span> <span class="token operator">=</span> memoryManager<span class="token punctuation">.</span>synchronized <span class="token punctuation">{</span>
    memoryUsed <span class="token operator">-</span> currentUnrollMemory
<span class="token punctuation">}</span>
</code></pre><ul>
<li><code>maxMemory</code>: 返回可用于存储的最大内存量。</li>
<li><code>memoryUsed</code>: 返回当前使用的存储内存总量。</li>
<li><code>blocksMemoryUsed</code>: 返回用于缓存块的内存量，不包括展开内存。</li>
</ul>
<h3 id="放置和获取块的方法">放置和获取块的方法 </h3>
<h4 id="putbytes-方法"><code>putBytes</code> 方法 </h4>
<pre data-role="codeBlock" data-info="scala" class="language-scala scala"><code><span class="token keyword keyword-def">def</span> putBytes<span class="token punctuation">[</span>T<span class="token operator">:</span> ClassTag<span class="token punctuation">]</span><span class="token punctuation">(</span>
    blockId<span class="token operator">:</span> BlockId<span class="token punctuation">,</span>
    size<span class="token operator">:</span> <span class="token builtin">Long</span><span class="token punctuation">,</span>
    memoryMode<span class="token operator">:</span> MemoryMode<span class="token punctuation">,</span>
    _bytes<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword keyword-=>">=&gt;</span> ChunkedByteBuffer<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Boolean</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    require<span class="token punctuation">(</span><span class="token operator">!</span>contains<span class="token punctuation">(</span>blockId<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string-interpolation"><span class="token id function">s</span><span class="token string">"Block </span><span class="token interpolation"><span class="token punctuation">$</span><span class="token expression">blockId</span></span><span class="token string"> is already present in the MemoryStore"</span></span><span class="token punctuation">)</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>memoryManager<span class="token punctuation">.</span>acquireStorageMemory<span class="token punctuation">(</span>blockId<span class="token punctuation">,</span> size<span class="token punctuation">,</span> memoryMode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-val">val</span> bytes <span class="token operator">=</span> _bytes<span class="token punctuation">(</span><span class="token punctuation">)</span>
        assert<span class="token punctuation">(</span>bytes<span class="token punctuation">.</span>size <span class="token operator">==</span> size<span class="token punctuation">)</span>
        <span class="token keyword keyword-val">val</span> entry <span class="token operator">=</span> <span class="token keyword keyword-new">new</span> SerializedMemoryEntry<span class="token punctuation">[</span>T<span class="token punctuation">]</span><span class="token punctuation">(</span>bytes<span class="token punctuation">,</span> memoryMode<span class="token punctuation">,</span> implicitly<span class="token punctuation">[</span>ClassTag<span class="token punctuation">[</span>T<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        entries<span class="token punctuation">.</span>synchronized <span class="token punctuation">{</span>
            entries<span class="token punctuation">.</span>put<span class="token punctuation">(</span>blockId<span class="token punctuation">,</span> entry<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        logInfo<span class="token punctuation">(</span><span class="token string-interpolation"><span class="token id function">s</span><span class="token string">"Block </span><span class="token interpolation"><span class="token punctuation">$</span><span class="token expression">blockId</span></span><span class="token string"> stored as bytes in memory (estimated size </span><span class="token interpolation"><span class="token punctuation">$</span><span class="token expression">size</span></span><span class="token string">, free </span><span class="token interpolation"><span class="token punctuation">${</span><span class="token expression">maxMemory <span class="token operator">-</span> blocksMemoryUsed</span><span class="token punctuation">}</span></span><span class="token string">)"</span></span><span class="token punctuation">)</span>
        <span class="token boolean">true</span>
    <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token punctuation">{</span>
        <span class="token boolean">false</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><ul>
<li><code>putBytes</code> 方法用于将块作为字节存储到内存中。</li>
<li>首先检查块是否已经存在，然后尝试获取存储该块所需的内存。</li>
<li>如果成功，则将块存储到 <code>entries</code> 中并记录日志。</li>
</ul>
<h4 id="putiterator-方法"><code>putIterator</code> 方法 </h4>
<pre data-role="codeBlock" data-info="scala" class="language-scala scala"><code><span class="token keyword keyword-private">private</span> <span class="token keyword keyword-def">def</span> putIterator<span class="token punctuation">[</span>T<span class="token punctuation">]</span><span class="token punctuation">(</span>
    blockId<span class="token operator">:</span> BlockId<span class="token punctuation">,</span>
    values<span class="token operator">:</span> Iterator<span class="token punctuation">[</span>T<span class="token punctuation">]</span><span class="token punctuation">,</span>
    classTag<span class="token operator">:</span> ClassTag<span class="token punctuation">[</span>T<span class="token punctuation">]</span><span class="token punctuation">,</span>
    memoryMode<span class="token operator">:</span> MemoryMode<span class="token punctuation">,</span>
    valuesHolder<span class="token operator">:</span> ValuesHolder<span class="token punctuation">[</span>T<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> Either<span class="token punctuation">[</span><span class="token builtin">Long</span><span class="token punctuation">,</span> <span class="token builtin">Long</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token comment">// 方法实现</span>
<span class="token punctuation">}</span>
</code></pre><ul>
<li><code>putIterator</code> 方法尝试将给定的块作为值或字节存储到内存中。</li>
<li>它逐渐展开迭代器，同时定期检查是否有足够的内存，以避免 OOM 异常。</li>
<li>如果成功展开并存储块，则返回存储的数据大小；否则，返回用于展开块的内存量。</li>
</ul>
<h4 id="getbytes-和-getvalues-方法"><code>getBytes</code> 和 <code>getValues</code> 方法 </h4>
<pre data-role="codeBlock" data-info="scala" class="language-scala scala"><code><span class="token keyword keyword-def">def</span> getBytes<span class="token punctuation">(</span>blockId<span class="token operator">:</span> BlockId<span class="token punctuation">)</span><span class="token operator">:</span> Option<span class="token punctuation">[</span>ChunkedByteBuffer<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-val">val</span> entry <span class="token operator">=</span> entries<span class="token punctuation">.</span>synchronized <span class="token punctuation">{</span> entries<span class="token punctuation">.</span>get<span class="token punctuation">(</span>blockId<span class="token punctuation">)</span> <span class="token punctuation">}</span>
    entry <span class="token keyword keyword-match">match</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-case">case</span> <span class="token keyword keyword-null">null</span> <span class="token keyword keyword-=>">=&gt;</span> None
        <span class="token keyword keyword-case">case</span> _<span class="token operator">:</span> DeserializedMemoryEntry<span class="token punctuation">[</span>_<span class="token punctuation">]</span> <span class="token keyword keyword-=>">=&gt;</span>
            <span class="token keyword keyword-throw">throw</span> SparkException<span class="token punctuation">.</span>internalError<span class="token punctuation">(</span><span class="token string">"should only call getBytes on serialized blocks"</span><span class="token punctuation">)</span>
        <span class="token keyword keyword-case">case</span> SerializedMemoryEntry<span class="token punctuation">(</span>bytes<span class="token punctuation">,</span> _<span class="token punctuation">,</span> _<span class="token punctuation">)</span> <span class="token keyword keyword-=>">=&gt;</span> Some<span class="token punctuation">(</span>bytes<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-def">def</span> getValues<span class="token punctuation">(</span>blockId<span class="token operator">:</span> BlockId<span class="token punctuation">)</span><span class="token operator">:</span> Option<span class="token punctuation">[</span>Iterator<span class="token punctuation">[</span>_<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-val">val</span> entry <span class="token operator">=</span> entries<span class="token punctuation">.</span>synchronized <span class="token punctuation">{</span> entries<span class="token punctuation">.</span>get<span class="token punctuation">(</span>blockId<span class="token punctuation">)</span> <span class="token punctuation">}</span>
    entry <span class="token keyword keyword-match">match</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-case">case</span> <span class="token keyword keyword-null">null</span> <span class="token keyword keyword-=>">=&gt;</span> None
        <span class="token keyword keyword-case">case</span> e<span class="token operator">:</span> SerializedMemoryEntry<span class="token punctuation">[</span>_<span class="token punctuation">]</span> <span class="token keyword keyword-=>">=&gt;</span>
            <span class="token keyword keyword-throw">throw</span> SparkException<span class="token punctuation">.</span>internalError<span class="token punctuation">(</span><span class="token string">"should only call getValues on deserialized blocks"</span><span class="token punctuation">)</span>
        <span class="token keyword keyword-case">case</span> DeserializedMemoryEntry<span class="token punctuation">(</span>values<span class="token punctuation">,</span> _<span class="token punctuation">,</span> _<span class="token punctuation">,</span> _<span class="token punctuation">)</span> <span class="token keyword keyword-=>">=&gt;</span>
            Some<span class="token punctuation">(</span>values<span class="token punctuation">.</span>iterator<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><ul>
<li><code>getBytes</code> 方法用于获取块的字节表示。</li>
<li><code>getValues</code> 方法用于获取块的值表示。</li>
</ul>
<h3 id="内存清理和块移除">内存清理和块移除 </h3>
<h4 id="remove-方法"><code>remove</code> 方法 </h4>
<pre data-role="codeBlock" data-info="scala" class="language-scala scala"><code><span class="token keyword keyword-def">def</span> remove<span class="token punctuation">(</span>blockId<span class="token operator">:</span> BlockId<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Boolean</span> <span class="token operator">=</span> memoryManager<span class="token punctuation">.</span>synchronized <span class="token punctuation">{</span>
    <span class="token keyword keyword-val">val</span> entry <span class="token operator">=</span> entries<span class="token punctuation">.</span>synchronized <span class="token punctuation">{</span>
        entries<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>blockId<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>entry <span class="token operator">!=</span> <span class="token keyword keyword-null">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        freeMemoryEntry<span class="token punctuation">(</span>entry<span class="token punctuation">)</span>
        memoryManager<span class="token punctuation">.</span>releaseStorageMemory<span class="token punctuation">(</span>entry<span class="token punctuation">.</span>size<span class="token punctuation">,</span> entry<span class="token punctuation">.</span>memoryMode<span class="token punctuation">)</span>
        <span class="token boolean">true</span>
    <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token punctuation">{</span>
        <span class="token boolean">false</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><ul>
<li><code>remove</code> 方法用于移除指定的块。</li>
<li>它首先从 <code>entries</code> 中移除块，然后释放相应的内存。</li>
</ul>
<h4 id="clear-方法"><code>clear</code> 方法 </h4>
<pre data-role="codeBlock" data-info="scala" class="language-scala scala"><code><span class="token keyword keyword-def">def</span> clear<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Unit</span> <span class="token operator">=</span> memoryManager<span class="token punctuation">.</span>synchronized <span class="token punctuation">{</span>
    entries<span class="token punctuation">.</span>synchronized <span class="token punctuation">{</span>
        entries<span class="token punctuation">.</span>values<span class="token punctuation">.</span>asScala<span class="token punctuation">.</span>foreach<span class="token punctuation">(</span>freeMemoryEntry<span class="token punctuation">)</span>
        entries<span class="token punctuation">.</span>clear<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    onHeapUnrollMemoryMap<span class="token punctuation">.</span>clear<span class="token punctuation">(</span><span class="token punctuation">)</span>
    offHeapUnrollMemoryMap<span class="token punctuation">.</span>clear<span class="token punctuation">(</span><span class="token punctuation">)</span>
    memoryManager<span class="token punctuation">.</span>releaseAllStorageMemory<span class="token punctuation">(</span><span class="token punctuation">)</span>
    logInfo<span class="token punctuation">(</span><span class="token string">"MemoryStore cleared"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><ul>
<li><code>clear</code> 方法用于清空 <code>MemoryStore</code> 中的所有块并释放所有内存。</li>
</ul>
<h3 id="解卷操作unroll">解卷操作(unroll) </h3>
<div class="admonition tip">
<p class="admonition-title">迭代器</p>
<p><strong>迭代器</strong>（Iterator）是一种设计模式，它提供一种方式来访问一个集合对象中的各个元素，而无需暴露该对象的内部表示。迭代器通常用于遍历列表、集合等数据结构。</p>
<p>在 Scala 中，<code>Iterator</code> 是一个标准的接口，它允许顺序访问集合中的元素，而不需要提前知道集合的大小。</p>
<pre data-role="codeBlock" data-info="scala" class="language-scala scala"><code><span class="token keyword keyword-val">val</span> numbers <span class="token operator">=</span> List<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span>
<span class="token keyword keyword-val">val</span> iterator <span class="token operator">=</span> numbers<span class="token punctuation">.</span>iterator

<span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span>iterator<span class="token punctuation">.</span>hasNext<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   println<span class="token punctuation">(</span>iterator<span class="token punctuation">.</span>next<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><p>在这个例子中，<code>iterator</code> 是一个用于遍历 <code>numbers</code> 列表的迭代器。</p>
</div>
<h4 id="临时展开内存">临时展开内存 </h4>
<p><strong>临时展开内存</strong>（Unroll Memory）是在计算过程中临时分配的内存，用于存储中间结果。在 Spark 中，临时展开内存用于在将数据块放入内存存储之前展开迭代器的数据。</p>
<p>临时展开内存的使用示例如下：</p>
<h4 id="迭代器示例">迭代器示例 </h4>
<p>假设我们有一个需要存储到内存中的迭代器，我们需要逐步展开这个迭代器，并在展开过程中确保有足够的内存来存储中间结果。这个过程使用临时展开内存来避免一次性分配过多内存导致 OOM（内存不足）异常。</p>
<pre data-role="codeBlock" data-info="scala" class="language-scala scala"><code><span class="token keyword keyword-import">import</span> <span class="token namespace">scala<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span></span>ClassTag
<span class="token keyword keyword-import">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>spark<span class="token punctuation">.</span>storage<span class="token punctuation">.</span></span><span class="token punctuation">{</span>BlockId<span class="token punctuation">,</span> MemoryMode<span class="token punctuation">}</span>
<span class="token keyword keyword-import">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>spark<span class="token punctuation">.</span>memory<span class="token punctuation">.</span></span><span class="token punctuation">{</span>MemoryManager<span class="token punctuation">,</span> TaskMemoryManager<span class="token punctuation">}</span>
<span class="token keyword keyword-import">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>spark<span class="token punctuation">.</span>internal<span class="token punctuation">.</span></span>Logging

<span class="token keyword keyword-class">class</span> MemoryStore <span class="token keyword keyword-extends">extends</span> Logging <span class="token punctuation">{</span>
<span class="token comment">// 假设一个简单的内存管理器</span>
<span class="token keyword keyword-val">val</span> memoryManager <span class="token operator">=</span> <span class="token keyword keyword-new">new</span> MemoryManager<span class="token punctuation">(</span><span class="token keyword keyword-null">null</span><span class="token punctuation">,</span> <span class="token keyword keyword-null">null</span><span class="token punctuation">,</span> <span class="token number">0.6</span><span class="token punctuation">,</span> <span class="token number">0.4</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>

<span class="token keyword keyword-def">def</span> putIterator<span class="token punctuation">[</span>T<span class="token operator">:</span> ClassTag<span class="token punctuation">]</span><span class="token punctuation">(</span>
   blockId<span class="token operator">:</span> BlockId<span class="token punctuation">,</span>
   values<span class="token operator">:</span> Iterator<span class="token punctuation">[</span>T<span class="token punctuation">]</span><span class="token punctuation">,</span>
   memoryMode<span class="token operator">:</span> MemoryMode<span class="token punctuation">)</span><span class="token operator">:</span> Either<span class="token punctuation">[</span><span class="token builtin">Long</span><span class="token punctuation">,</span> <span class="token builtin">Long</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>

   <span class="token keyword keyword-var">var</span> elementsUnrolled <span class="token operator">=</span> <span class="token number">0</span>
   <span class="token keyword keyword-var">var</span> keepUnrolling <span class="token operator">=</span> <span class="token boolean">true</span>
   <span class="token keyword keyword-var">var</span> unrollMemoryUsed <span class="token operator">=</span> <span class="token number">0L</span>
   <span class="token keyword keyword-val">val</span> initialMemoryThreshold <span class="token operator">=</span> <span class="token number">1024L</span>
   <span class="token keyword keyword-var">var</span> memoryThreshold <span class="token operator">=</span> initialMemoryThreshold

   keepUnrolling <span class="token operator">=</span> memoryManager<span class="token punctuation">.</span>acquireUnrollMemory<span class="token punctuation">(</span>blockId<span class="token punctuation">,</span> initialMemoryThreshold<span class="token punctuation">,</span> memoryMode<span class="token punctuation">)</span>

   <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>keepUnrolling<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      logWarning<span class="token punctuation">(</span><span class="token string-interpolation"><span class="token id function">s</span><span class="token string">"Failed to reserve initial memory threshold of </span><span class="token interpolation"><span class="token punctuation">$</span><span class="token expression">initialMemoryThreshold</span></span><span class="token string"> bytes."</span></span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token punctuation">{</span>
      unrollMemoryUsed <span class="token operator">+=</span> initialMemoryThreshold
   <span class="token punctuation">}</span>

   <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span>values<span class="token punctuation">.</span>hasNext <span class="token operator">&amp;&amp;</span> keepUnrolling<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword keyword-val">val</span> value <span class="token operator">=</span> values<span class="token punctuation">.</span>next<span class="token punctuation">(</span><span class="token punctuation">)</span>
      elementsUnrolled <span class="token operator">+=</span> <span class="token number">1</span>
      <span class="token comment">// 估算当前存储的大小</span>
      <span class="token keyword keyword-val">val</span> currentSize <span class="token operator">=</span> elementsUnrolled <span class="token operator">*</span> <span class="token number">8L</span> <span class="token comment">// 假设每个元素占用 8 字节</span>
      <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>currentSize <span class="token operator">&gt;=</span> memoryThreshold<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword keyword-val">val</span> amountToRequest <span class="token operator">=</span> currentSize <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">-</span> memoryThreshold
      keepUnrolling <span class="token operator">=</span> memoryManager<span class="token punctuation">.</span>acquireUnrollMemory<span class="token punctuation">(</span>blockId<span class="token punctuation">,</span> amountToRequest<span class="token punctuation">,</span> memoryMode<span class="token punctuation">)</span>
      <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>keepUnrolling<span class="token punctuation">)</span> <span class="token punctuation">{</span>
         unrollMemoryUsed <span class="token operator">+=</span> amountToRequest
      <span class="token punctuation">}</span>
      memoryThreshold <span class="token operator">+=</span> amountToRequest
      <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>

   <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>keepUnrolling<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      Right<span class="token punctuation">(</span>unrollMemoryUsed<span class="token punctuation">)</span>
   <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token punctuation">{</span>
      Left<span class="token punctuation">(</span>unrollMemoryUsed<span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 示例使用</span>
<span class="token keyword keyword-object">object</span> MemoryStoreExample <span class="token keyword keyword-extends">extends</span> App <span class="token punctuation">{</span>
<span class="token keyword keyword-val">val</span> memoryStore <span class="token operator">=</span> <span class="token keyword keyword-new">new</span> MemoryStore
<span class="token keyword keyword-val">val</span> blockId <span class="token operator">=</span> <span class="token keyword keyword-new">new</span> BlockId <span class="token punctuation">{</span>
   <span class="token keyword keyword-override">override</span> <span class="token keyword keyword-def">def</span> name<span class="token operator">:</span> <span class="token builtin">String</span> <span class="token operator">=</span> <span class="token string">"exampleBlock"</span>
<span class="token punctuation">}</span>
<span class="token keyword keyword-val">val</span> values <span class="token operator">=</span> Iterator<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span>

<span class="token keyword keyword-val">val</span> result <span class="token operator">=</span> memoryStore<span class="token punctuation">.</span>putIterator<span class="token punctuation">(</span>blockId<span class="token punctuation">,</span> values<span class="token punctuation">,</span> MemoryMode<span class="token punctuation">.</span>ON_HEAP<span class="token punctuation">)</span>
result <span class="token keyword keyword-match">match</span> <span class="token punctuation">{</span>
   <span class="token keyword keyword-case">case</span> Right<span class="token punctuation">(</span>size<span class="token punctuation">)</span> <span class="token keyword keyword-=>">=&gt;</span> println<span class="token punctuation">(</span><span class="token string-interpolation"><span class="token id function">s</span><span class="token string">"Block stored successfully with size </span><span class="token interpolation"><span class="token punctuation">$</span><span class="token expression">size</span></span><span class="token string"> bytes."</span></span><span class="token punctuation">)</span>
   <span class="token keyword keyword-case">case</span> Left<span class="token punctuation">(</span>memoryUsed<span class="token punctuation">)</span> <span class="token keyword keyword-=>">=&gt;</span> println<span class="token punctuation">(</span><span class="token string-interpolation"><span class="token id function">s</span><span class="token string">"Failed to store block. Unrolled memory used: </span><span class="token interpolation"><span class="token punctuation">$</span><span class="token expression">memoryUsed</span></span><span class="token string"> bytes."</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>在这个示例中，<code>putIterator</code> 方法逐步展开 <code>values</code> 迭代器，并定期检查是否需要请求更多内存。<code>MemoryManager</code> 用于管理临时展开内存的分配和释放。</p>
<h3 id="其他方法">其他方法 </h3>
<ul>
<li><code>evictBlocksToFreeSpace</code>: 尝试逐出块以腾出指定空间用于存储新块。</li>
<li><code>reserveUnrollMemoryForThisTask</code>: 为当前任务保留展开内存。</li>
</ul>
<p>这些方法共同工作，确保内存块的存储和管理能够高效且安全地进行。通过对内存块的操作进行同步控制，可以避免并发问题，并确保内存的高效利用。</p>
<p><code>MemoryStore</code> 类用于在内存中管理和存储数据块。它有多种内存管理策略，包括处理数据块的序列化和反序列化。以下是该类主要功能和方法的简要说明：</p>
<ol>
<li>
<p><strong>成员变量和构造函数</strong>：</p>
<ul>
<li><code>entries</code>: 使用 <code>LinkedHashMap</code> 存储所有块的信息。</li>
<li><code>onHeapUnrollMemoryMap</code> 和 <code>offHeapUnrollMemoryMap</code>: 分别用于记录堆内存和堆外内存中用于解卷的内存量。</li>
<li><code>unrollMemoryThreshold</code>: 解卷块之前请求的初始内存量。</li>
</ul>
</li>
<li>
<p><strong>主要方法</strong>：</p>
<ul>
<li><code>putBytes</code>: 尝试将一个字节数组放入内存。如果内存足够，就将块存储为字节；否则返回 <code>false</code>。</li>
<li><code>putIterator</code>: 尝试将一个迭代器中的数据放入内存。这是一个逐步解卷的过程，以避免内存溢出。</li>
<li><code>putIteratorAsValues</code> 和 <code>putIteratorAsBytes</code>: 分别将数据块以值或字节形式存储到内存中。</li>
<li><code>getBytes</code> 和 <code>getValues</code>: 根据块 ID 获取存储的字节或值。</li>
<li><code>remove</code>: 移除指定块的内存条目，并释放相关内存。</li>
<li><code>clear</code>: 清除所有块，释放所有内存。</li>
<li><code>evictBlocksToFreeSpace</code>: 尝试通过逐出其他块来释放指定空间。</li>
</ul>
</li>
<li>
<p><strong>内存管理</strong>：</p>
<ul>
<li><code>reserveUnrollMemoryForThisTask</code> 和 <code>releaseUnrollMemoryForThisTask</code>: 分别用于请求和释放用于解卷的内存。</li>
<li><code>currentUnrollMemory</code> 和 <code>currentUnrollMemoryForThisTask</code>: 获取当前内存使用情况。</li>
</ul>
</li>
<li>
<p><strong>日志记录</strong>：</p>
<ul>
<li>类中大量使用日志记录（<code>logInfo</code>, <code>logWarning</code> 等）来跟踪内存使用情况和操作结果。</li>
</ul>
</li>
</ol>
<h3 id="代码中的一些关键点">代码中的一些关键点 </h3>
<ul>
<li><strong>线程安全</strong>：在处理内存和块操作时，使用 <code>synchronized</code> 确保线程安全。</li>
<li><strong>内存策略</strong>：支持堆内存和堆外内存两种存储模式，并且根据内存情况动态调整内存使用策略。</li>
<li><strong>解卷策略</strong>：为了防止 OOM 异常，<code>putIterator</code> 方法会逐步解卷数据，同时动态请求内存。</li>
</ul>

      </div>
      
      
    
    
    <script type="module">
// TODO: If ZenUML gets integrated into mermaid in the future,
//      we can remove the following lines.


var MERMAID_CONFIG = ({"startOnLoad":false});
if (typeof MERMAID_CONFIG !== 'undefined') {
  MERMAID_CONFIG.startOnLoad = false
  MERMAID_CONFIG.cloneCssStyles = false
  MERMAID_CONFIG.theme = "default"
}

mermaid.initialize(MERMAID_CONFIG || {})
if (typeof(window['Reveal']) !== 'undefined') {
  function mermaidRevealHelper(event) {
    var currentSlide = event.currentSlide
    var diagrams = currentSlide.querySelectorAll('.mermaid')
    for (var i = 0; i < diagrams.length; i++) {
      var diagram = diagrams[i]
      if (!diagram.hasAttribute('data-processed')) {
        mermaid.init(null, diagram, ()=> {
          Reveal.slide(event.indexh, event.indexv)
        })
      }
    }
  }
  Reveal.addEventListener('slidetransitionend', mermaidRevealHelper)
  Reveal.addEventListener('ready', mermaidRevealHelper)
  await mermaid.run({
    nodes: document.querySelectorAll('.mermaid')
  })
} else {
  await mermaid.run({
    nodes: document.querySelectorAll('.mermaid')
  })
}
</script>
    
    
    
  
    </body></html>